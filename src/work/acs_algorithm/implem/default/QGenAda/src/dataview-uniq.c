/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>

#include "asn1crt_encoding.h"
#include "asn1crt_encoding_uper.h"

#include "dataview-uniq.h"




void asn1SccT_Float_Initialize(asn1SccT_Float* pVal)
{
	(void)pVal;


	(*(pVal)) = 0.0000000000000000000E+000;
}

flag asn1SccT_Float_IsConstraintValid(const asn1SccT_Float* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-3.3999999999999999612E+038 <= (*(pVal))) && ((*(pVal)) <= 3.3999999999999999612E+038));
    *pErrCode = ret ? 0 :  ERR_T_FLOAT; 

	return ret;
}

flag asn1SccT_Float_Encode(const asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Float_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeReal(pBitStrm, (*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Float_Decode(asn1SccT_Float* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeReal(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_FLOAT;

	return ret  && asn1SccT_Float_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_B_b_T_Initialize(asn1SccT_B_b_T* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 15) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_B_b_T_IsConstraintValid(const asn1SccT_B_b_T* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 15; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_B_b_T_Encode(const asn1SccT_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_B_b_T_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)15) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_B_b_T_Decode(asn1SccT_B_b_T* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)15) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_B_b_T_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Omega_Initialize(asn1SccT_Omega* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_Omega_IsConstraintValid(const asn1SccT_Omega* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_Omega_Encode(const asn1SccT_Omega* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Omega_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Omega_Decode(asn1SccT_Omega* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_Omega_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_MT_Working_Initialize(asn1SccT_MT_Working* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_MT_Working_IsConstraintValid(const asn1SccT_MT_Working* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_MT_Working_Encode(const asn1SccT_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_MT_Working_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_MT_Working_Decode(asn1SccT_MT_Working* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_MT_Working_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Control_Initialize(asn1SccT_Control* pVal)
{
	(void)pVal;

    int i1;

	i1 = 0;
	while (i1< 3) {
	    asn1SccT_Float_Initialize((&(pVal->arr[i1])));
	    i1 = i1 + 1;
	}

}

flag asn1SccT_Control_IsConstraintValid(const asn1SccT_Control* pVal, int* pErrCode)
{
    flag ret = TRUE;
    int i1;
    for(i1 = 0; ret && i1 < 3; i1++) 
    {
    	ret = asn1SccT_Float_IsConstraintValid((&(pVal->arr[i1])), pErrCode);
    }

	return ret;
}

flag asn1SccT_Control_Encode(const asn1SccT_Control* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	int i1;
	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Control_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    	
	    for(i1=0; (i1 < (int)3) && ret; i1++) 
	    {
	    	ret = asn1SccT_Float_Encode((&(pVal->arr[i1])), pBitStrm, pErrCode, FALSE);
	    }
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Control_Decode(asn1SccT_Control* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;

	int i1;

		
	for(i1=0; (i1 < (int)3) && ret; i1++) 
	{
		ret = asn1SccT_Float_Decode((&(pVal->arr[i1])), pBitStrm, pErrCode);
	}

	return ret  && asn1SccT_Control_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int32_Initialize(asn1SccT_Int32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int32_IsConstraintValid(const asn1SccT_Int32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-2147483648LL <= (*(pVal))) && ((*(pVal)) <= 2147483647LL));
    *pErrCode = ret ? 0 :  ERR_T_INT32; 

	return ret;
}

flag asn1SccT_Int32_Encode(const asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -2147483648LL, 2147483647LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int32_Decode(asn1SccT_Int32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -2147483648LL, 2147483647LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT32;

	return ret  && asn1SccT_Int32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt32_Initialize(asn1SccT_UInt32* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt32_IsConstraintValid(const asn1SccT_UInt32* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 4294967295UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT32; 

	return ret;
}

flag asn1SccT_UInt32_Encode(const asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 4294967295LL);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt32_Decode(asn1SccT_UInt32* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 4294967295LL);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT32;

	return ret  && asn1SccT_UInt32_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Int8_Initialize(asn1SccT_Int8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_Int8_IsConstraintValid(const asn1SccT_Int8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((-128LL <= (*(pVal))) && ((*(pVal)) <= 127LL));
    *pErrCode = ret ? 0 :  ERR_T_INT8; 

	return ret;
}

flag asn1SccT_Int8_Encode(const asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Int8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintWholeNumber(pBitStrm, (*(pVal)), -128, 127);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Int8_Decode(asn1SccT_Int8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintWholeNumber(pBitStrm, pVal, -128, 127);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_INT8;

	return ret  && asn1SccT_Int8_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_UInt8_Initialize(asn1SccT_UInt8* pVal)
{
	(void)pVal;


	(*(pVal)) = 0;
}

flag asn1SccT_UInt8_IsConstraintValid(const asn1SccT_UInt8* pVal, int* pErrCode)
{
    flag ret = TRUE;
    ret = ((*(pVal)) <= 255UL);
    *pErrCode = ret ? 0 :  ERR_T_UINT8; 

	return ret;
}

flag asn1SccT_UInt8_Encode(const asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_EncodeConstraintPosWholeNumber(pBitStrm, (*(pVal)), 0, 255);
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_UInt8_Decode(asn1SccT_UInt8* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_DecodeConstraintPosWholeNumber(pBitStrm, pVal, 0, 255);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_UINT8;

	return ret  && asn1SccT_UInt8_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Boolean_Initialize(asn1SccT_Boolean* pVal)
{
	(void)pVal;


	(*(pVal)) = FALSE;
}

flag asn1SccT_Boolean_IsConstraintValid(const asn1SccT_Boolean* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Boolean_Encode(const asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
	    BitStream_AppendBit(pBitStrm,(*(pVal)));
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Boolean_Decode(asn1SccT_Boolean* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;


	ret = BitStream_ReadBit(pBitStrm, pVal);
	*pErrCode = ret ? 0 : ERR_UPER_DECODE_T_BOOLEAN;

	return ret  && asn1SccT_Boolean_IsConstraintValid(pVal, pErrCode);
}



void asn1SccT_Null_Record_Initialize(asn1SccT_Null_Record* pVal)
{
	(void)pVal;


}

flag asn1SccT_Null_Record_IsConstraintValid(const asn1SccT_Null_Record* pVal, int* pErrCode)
{
    flag ret = TRUE;
	(void)pVal;
    ret = TRUE;
    *pErrCode = 0;

	return ret;
}

flag asn1SccT_Null_Record_Encode(const asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints)
{
    flag ret = TRUE;
	(void)pBitStrm;


	*pErrCode = 0;
	ret = bCheckConstraints ? asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode) : TRUE ;
	if (ret && *pErrCode == 0) {
    } /*COVERAGE_IGNORE*/

	
    return ret;
}

flag asn1SccT_Null_Record_Decode(asn1SccT_Null_Record* pVal, BitStream* pBitStrm, int* pErrCode)
{
    flag ret = TRUE;
	*pErrCode = 0;
	(void)pBitStrm;



	return ret  && asn1SccT_Null_Record_IsConstraintValid(pVal, pErrCode);
}

